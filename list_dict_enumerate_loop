1. list
2. dict
3. enumerate
4. loops


###############################################################################################################
##################################### 1. LIST #####################################
###############################################################################################################
list_raster_obj = list(set(list_raster_obj))
list_raster_obj.sort(key = helper_functions.natural_keys) #sort as a human would do

Bei einer globalen Liste, die in einer funktion genutzt wird, muss man auch global Liste schreiben, außer man appended etwas zur Liste.
Wird der Liste etwas zugeteilt, dann ohne global nur lokal aktuell. Außerhalb leer, deswegen global Liste schreiben in der Funktion.

l = [1,0,0,1,0,2,4,3,1]
x = ('key1', 'key2', 'key3')
l_unique:list = list(dict.fromkeys(l).keys()) # [1, 0, 2, 4, 3]


###############################################################################################################
##################################### 2. DICTIONARY #####################################
###############################################################################################################
Merge Dictionaries in Python https://favtutor.com/blogs/merge-dictionaries-python

thisdict = {
  "brand": "Ford",
  "electric": False,
  "year": 1964,
  "colors": ["red", "white", "blue"],
  1:2,
  200: {'a':4, 5:55}
}

.items() return each item in a dictionary, as tuples in a list.
.keys()==dict 
+ dict_keys = thisdict.keys(); The list of the keys is a view of the dictionary. Changes überall verfügbar.
.values() The list of the values is a view of the dictionary, meaning that any changes done to the dictionary will be reflected in the values list.

del dict deleted, dict.clear()
dict['a'], dict.get('a')
dict.pop(key) del dict[key]
dict.popitem() #remove last

for i, el in enumerate(thisdict, start=1):
	print(i, el, thisdict[el])
      1 brand Ford
      2 electric False
      3 year 1964
      4 colors ['red', 'white', 'blue']
      5 1 2
      6 200 {'a': 4, 5: 55}

for x in thisdict:
  print(x) #key
  print(thisdict[x]) #val

for k, v in thisdict.items():
  print(k, v)
for el in thisdict.items():
  print(el[0], el[1])
----------------------------------------------------------------
myfamily = {
  "child1" : {
    "name" : "Emil",
    "year" : 2004
  },
  "child2" : {
    "name" : "Tobias",
    "year" : 2007
  }
}
keys = myfamily.keys()
print(myfamily.keys()) #dict_keys(['child1', 'child2'])

for child in myfamily:
print(myfamily[child]['name'])
  #Emil
  #Tobias  
---------------------------------------------------------------
#dict comprehension
dict_names = {name:len(name) for name in list_names}
---------------------------------------------------------------
dict_ras_complete_metadata = dict_ras_skeleton_metadata | dict_ras_filler_metadata
#list_raster.sort(key = helper_functions.natural_keys)

#sort the dictionary for keys
dict_ras_complete_metadata = dict(sorted(dict_ras_complete_metadata.items()))
---------------------------------------------------------------
dicta = {1:'a', 2:'b', 'ey':'yo'}

print(list(dicta.keys())[2]) #ey
print(list(dicta.values())[2]) #yo
---------------------------------------------------------------
find index in dictionary of a keys https://sparkbyexamples.com/python/get-the-index-of-key-in-python-dictionary/?expand_article=1
---------------------------------------------------------------
threshold = int(file.split("_")[-1])
#'_'.join(file.split("_")[:-1])
dict_ras_skeleton_metadata[threshold] = [-1,-1,-1,file] #counter_cluster, %absolute, %relative to prior raster, filename
cluster_amount = raster_query.count_cluster_in_raster(file)
dict_ras_skeleton_metadata[threshold][0] = cluster_amount   
---------------------------------------------------------------
---------------------------------------------------------------
---------------------------------------------------------------
---------------------------------------------------------------


###############################################################################################################
##################################### 3. ENUMERATE #####################################
###############################################################################################################
https://www.w3schools.com/python/ref_func_enumerate.asp
https://realpython.com/python-enumerate/
https://www.coursera.org/tutorials/enumerate-python

enumerate(): bietet count + val als tuple (count, val)
nimmt als arg eine collection (sequence of values) und returniert es als ein enumerate Objekt. Hinzugefügt wird ein Counter als Key für das Objekt. Default 0.
Bei jeder Iteration wird das next element aus der iterable collection genommen.
enum_obj = enumerate(iterable, start=0) #iterable obj welches Iteration unterstützt
enum_obj mit list() und tuple() konvertierbar

--------------
2 var: count, val
enumerate(seq of val) returniert ITERATOR; next() auf ITERATOR yields ein tuple mit (count, val)

tupler = ('apple', 'banana', 'cherry')
enum_obj = enumerate(tupler)

print(next(enum_obj)) #(0, 'apple')
print(next(enum_obj)) #(1, 'banana')
...until StopIteration is raised
print(list(enum_obj)) #[(2, 'cherry')]
--------------
lister = [4,5,6]
for index, ras in enumerate(lister,1):
    print(f' {index}. {ras}')
		#1. 4
		#2. 5
		#3. 6
--------------
grocery = ['bread', 'milk', 'butter']
for item in enumerate(grocery):
  print(item)
  (0, 'bread')
  (1, 'milk')
  (2, 'butter')
----------------
for i, (k,v) in enumerate(dict_ras_thresholds_skeleton.items(),1):        
	print(f'name of {i}. skeletor raster: {k} and val: {v}')
###############################################################################################################
##################################### 4. LOOP #####################################
###############################################################################################################
froma,toa,inca = 10,15,1
for val in range(froma, toa, inca):
    print(f'Value in loop: {val}')
