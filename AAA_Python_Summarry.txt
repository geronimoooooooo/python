+ in der console: python oder py
+ exit() um die command line zu verlassen
+ All classes have a function called __init__(), which is always executed when the class is being initiated. 
The __init__() function is called automatically every time the class is being used to create a new object.
+ self == this, reference to current instance of class, and is used to access variables that belongs to the class.
+ Import only the person1 dictionary from the module: from mymodule import person1
+ Python is a type-inferred language, so you don't have to explicitly define the variable type. It automatically knows that programiz.pro is a string 
and declares the site_name variable as a string.
+ snake_case, MACRO_CASE, camelCase, CapWords
+ Division /...flaot, //...int; 10/3=3.33; 10//3=3
+ Module is a file that contains code to perform a specific task. A module may contain variables, functions, classes etc.
++ Eine .py Datei ist ein module und mehrere modules/.py in einemm Ordner sind ein PACKAGE
++ Wenn ein module eine __name__=='__main__' hat, dann ist es selbständig ausführbar und ein Skript
+ from math import pi as p

+ we can use the dir() function to list all the function names in a module
+ print(random.choice(list1)) # get random item from list1 
+ The index of -1 refers to the last item, -2 to the second last item and so on.

+ List comprehension: numbers = [number*number for number in range(1, 6)]
++ return [v for i, v in enumerate(iterable, start=1) if not i % 2]
+ programming_languages = ["JavaScript","Python","Java","Python","C++","Python"]
++python_indices  = [index for (index, item) in enumerate(programming_languages) if item == "Python"]
dict_compr = {i:i*i for i in range(10)}
int_docs_info = {int(k) : v for k, v in docss_info.items()}
set_compr = {i*i for i in range(10)}
words = [word.lower() for word in my_str.split()] # breakdown the string into a list of words 

+ a= 3.14159; b= 123.4567; print('a: %0.3f and b: %0.2f' %(a ,b)) ==> a: 3.142 and b: 123.46 (print('val: %0.2f' %val))
+  Encapsulation refers to the bundling of attributes and methods inside a single class. 
It prevents outer classes from accessing and changing attributes and methods of a class. This also helps to achieve data hiding.
+ __init__, __str__ or __getitem__ methods. These are special methods that are called by the Python interpreter and not by you


+ Mit der Yield-Anweisung können wir eine Generatorfunktion erstellen. Die Funktion liest und liefert bei jeder Iteration oder 
jedem Funktionsaufruf next() den neuen Datenblock.
>>> for count, (one, two, three) in enumerate(zip(first, second, third)):
...     print(count, one, two, three)
+ Docstring: print(func.__doc__) or print(help(func))
+ Mit cython C code (library) mit python linken, damit schwere Arbeit in C ausgeführt wird
+ statt == is nutzen. if x==True: => if x is True:
+ use time.perf_counter() statt time.time() um duration zu messen: https://www.webucator.com/article/python-clocks-explained/
+ use numpy for math/arrays and pandas for "dataanalysis"
+ Python is compiled to "byte-code" (nicht zu machinecode) und diese files sind in ".pyc files" oder "__pycache__". 
Der "byte-code" ist dann run by the interpreter.
+ pep8 ist ein stylecode 
+ n = 3.1499999; nn = round(n, 2);;;nnn = n*1000;nnn = int(nnn);nnn = nnn/100
+ lister=[0]; lis=lister; lis.clear() cleart auch lister; lis=[] lister hat noch die 0; lis[:] = irgendwas; würde auch lister mit verändern
+ deque: stack/que Datenstruktur für schnelle Operationen auf beiden Seitenenden
>lambda function nutzen wenn eine anonymous function kurzfristig (in einer anderen Funktion) gebraucht wird. Bez = lambda args: expression; Bez(args). 

+pip package manager um zu installieren und software packages zu managen
+ arcpy.Raster() ras.name .path .catalogPath .maximum .noDataValue
+ l2=l1.copy() hardcopy, mit unterschiedlichen ids, aber nur auf lvl1 Ebene. für lvl2: import copy; copy.deepcopy(list)
lis1 = lis.copy() shallow copy bedeutet, dass wir 1d arrays ohne Seiteneffekte kopieren können; 2 Listen mit eigenen ids

+ 47 Stringmethodshttps://www.youtube.com/watch?v=bnSYeYFRCaA 
str: .casefold() macht straße == strasse => true
str.center(20,'.') .rjust(20, '_') .rfind() .find() returns -1, .index() wirft error .format_map(dict_xy) .isdecimal() .join() .lstrip('ab') .partition("=") .rpartition("=") .split(maxsplit=2) .rsplit()

text: str ='a' ist type hint oder type annotation


===Commands===
>python --version
>pip --version
>pip install <nameOfModule> #z.B. pip install rasterio==1.3.3
>pip list #listet alle installierten packages/module
>pip show <nameOfModule> #zeigt details und wo das modul abgespeichert ist
>py -0p #zeigt Version zu alle gefundenen installierten python.exe mit Pfad
>where *python* #listet alle Pfade zu gefundenen python.exe die im PATH/Systemvariable gesetzt sind
>python -c "import sys; print(sys.exec_prefix);print(str(sys.path).replace(',', '\n')); #zeigt den Pfad zur aktuellen default Pythonversion an
>ECHO.%PATH:;= & ECHO.% #listet alles aus der Systemvariable Path auf


* In order to use the arcpy module you will need to use the Python interpreter that is installed by your ArcGIS client.
  Wenn mehrere unterschiedliche Python Versionen vorhanden sind, dann kann eine spezielle genutzt werden, indem
  Python aus dem Ordner, wo sich die gewünschte spezielle Version befindet, über commandline gestartet wird.  
  C:\Program Files\ArcGIS\Pro\bin\Python\envs\arcgispro-py3>python --version
  Python 3.9.11
  Falls python nicht in dem Ordner aufgerufen, dann nimmt das system die "default python version" her.
  
  
  
  ===for===
for el in list:
for i, el in enumerate(list):
for el in zip(a, b):
for i, (el_a, el_b) in enumerate(zip(a, b)):
for i, el in enumerate(range(1,25), start=1):
    print("{}.{}".format(i,(3000 * (1+el/25))))

for key in dict:
for key in list(dict.keys()): #make copy of keys because they might get modified
for key, val in dict.items(): #key-value pairs

#referring to their index number
for i in range(len(thistuple)):
print(thistuple[i])
  
  for i, el in enumerate(list, start=1):
  print(i, el)
  
###############################
Mastering Python - Everything You Need To Know To Become a Python Master
https://www.youtube.com/watch?v=p15xzjzR9j0
###############################

===immutable int/string/list===
Zahlen und Strings sind in Python immutable. 2 Variablen teilen nicht die selbe Referenz sobald eine verändert wurde. Listen hingegen schon.
a = 'a'
b = a
print(a,b) ist 'a''a'
a = 'c' #a hat neuen Wert und neue Speicheradresse erhalten. Nicht mehr selbe Referenz wie b
print(a,b) ist 'c''a'

Änderungen bei 1 Liste haben überall bei den anderen Listen die selben Änderungen.


===Iterator===
https://youtu.be/qeOcZiSp3tE?t=448

===yield===
https://youtu.be/qeOcZiSp3tE?t=626

################################################## https://pythonexamples.or ##################################################
multi-line comment '''a'''
Zero is considered to be FALSE
compound expressen: join 2 boolean expression with AND
logical not operator: if not value: (um zu sehen ob etwas leer ist; falls ja, dann wird true teil geprintet; value =[])
ternary operator: max = a if a > b else b ;; print('Python') if a > b else print('Examples')-
default value: def add(a, b, c = 0):
multiple arguments: def add(*args):    for arg in args:; the asterisk symbol is called unpacking operator
mit *args eine unbestimmte Anzahl von Argumenten; mit **kwargs eine unbestimmte Anzahl von "named Argumenten"
- def myFunction(*args, **kwargs):
- myFunction("hello", "mars", a = 24, b = 87, c = 3, d = 46) #print(args) print(kwargs)
- datatype von *args ist tuple und von **kwargs ist es dict
return multiple values from function:  a,b = swap() (return a,b)
